source code -->pan.baidu.com/Honkhat20

OpenGL本身只是一套操作GPU绘图的API，不提供窗口相关的操作，WGL、GLUT等封装了常用的窗口需求，所以如果你想在一个WTL窗口或者其他的基本窗口中调用OpenGL API绘图是完全可行的。


GLEW: the OpenGL Extension Wrangler Library. 一定放在其他include的前面!


glewInit();必须放在glut相关初始化完毕后!


glBindBuffer(GL_ARRAY_BUFFER, VBO);
要点：
	GL_ARRAY_BUFFER : 缓冲区存储的是顶点数组;
	GL_ELEMENT_ARRAY_BUFFER : 缓冲区存储的是顶点索引的数组;


glEnableVertexAttribArray(0);
要点:
	0: position的索引;(其他索引还有color, normal..)
	针对固定管线设置的, 固定管线在可编程管线不可用时就被激活了;
	

glBindBuffer(GL_ARRAY_BUFFER, VBO);
要点:
	告诉当前要激活哪个BUFFER, 这个BUFFER的数据是谁。


glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
功能: 在glBindBuffer后，告诉GL如何解析BUFFER中的数据。
要点:
	0: 属性索引，这里是position的索引;
	3: 这个属性有3个分量，x y z;
	GL_FLOAT: 分量的数据类型;
	GL_FALSE: 属性值在进入固定管线前是否进行归一化;
	0: 两个顶点属性数据之间的偏移量，如果每个顶点包含position normal两个属性的话，这个值就是6*=24;
	0: 顶点内部属性之间的偏移量，同样上面例子，如果指定position这个值就是0，如果是normal这个值就是12.


glDrawArrays(GL_POINTS, 0, 1);
功能: 最简单的绘制API方法。把上面方法指定的数据模型 定为--> 点拓扑。
要点:
	GL_POINTS : 告诉GL我要绘制的拓扑类型，其他还有GL_TRIANGLES，0-2是第一个顶点坐标..
	0: 起始偏移地址;
	1: 顶点数量;

glDisableVertexAttribArray(0);
要点：
	GL绘制模式一般为立即模式，用完要马上恢复原来的状态，因为状态机机制，如果不恢复，可能带来问题。


OpenGL的绘制方法大体可以分为2类: 直接绘制 和 索引绘制。在游戏中，大量的三角形数据是重复的，使用索引绘制方法。

====================================================================================================================================================
可编程管线 相较于 固定管线，让你拥有了更多的弹性Flexibility和创新Innovation的可能。


Pipeline Step 1: 顶点处理。所有的顶点都将在这里经受矩阵变换。顶点着色器并不知道这些点将来要被组装成什么样的图元。

Pipeline Step 2: 几何形状处理。几何着色器已经知道"这些顶点将要被组装成什么形状", 主要对目标拓扑(形状)做一些优化的工作，比如分解成三角元.

Pipeline Step 3: 剪切处理(Clipper). 把不在Normalized Box里面的顶点全部剔除。注意W是缩放因子。

Pipeline Step 4: 光栅化/片段(像素)处理。片段(像素)处理器对每个像素进行处理，比如设置颜色等.

如果你不设置顶点着色器(VS)、几何着色器(GS)、片段着色器(FS), 对应的处理部分就会由默认的固定管线操作代替。

glValidateProgram(ShaderProgram);
要点:
	可能在开发版本上加上这句，最后产品去掉来提升运行效率。

glUseProgram(ShaderProgram);
要点:
	如果使用NULL或者其他的参数重新掉用了glUseProgram, 自动disable last shader-program.

#version 330
功能: 告诉编译器我们使用GLSL 3.3的版本，如果低于，会报错。

layout (location = 0) in vec3 Position;
要点：
	lacation=0 绑定了0对应的顶点属性是position. 
	一般在稍微大点的程序中，都由编译器自动分配，然后动态查询(runtime query).

gl_Position = vec4(0.5 * Position.x, 0.5 * Position.y, Position.z, 1.0);
要点:
	gl_Position是内置的变量.

out vec4 FragColor;
FragColor = vec4(1.0, 0.0, 0.0, 1.0);
要点: GL默认使用的像素渲染色是白色， 这样设置了红色。Alpha的含义应该和Opaque一样，都是“不透明度”.

glutPostRedisplay(); 相当于 Gdi/+中的 InvalidateRect();
====================================================================================================================================================
如何从点(X, Y, Z)通过平移(X1, Y1, Z1)到达(X+X1, Y+Y1, Z+Z1)?
方法: OpenGL列存储(一个点是一个列向量，而非行向量)优先。把起始点(X,Y, Z)构造进一个1×4的矩阵，把(X1, Y1, Z1)构造进一个4×4的矩阵。(ogldev的tutorial文章中把(X,Y,Z)与(X1,Y1,Z1)位置弄反了,不好理解了)
| 1 0 0 X1 |              | X |                 | X + w*X1 |
| 0 1 0 Y1 |              | Y |                 | Y + w*Y1 |
| 0 0 1 Z1 |       ×     | Z |         =       | Z + w*Z1 |
| 0 0 0 1  |              | w |                 |     w    |
(这里w设为1)
Column 1: X轴方向向量; Column 2: Y轴; Column 3: Z 轴; Column 4: 平移向量.
通过这个矩阵构造方法，可以看到第4个变量w之所以称为"缩放因子"的原因了。对于点，一般w设为1，对于向量，则设为0.因为点“平移”后就变成了另一个点，向量平移还是原来的向量（起止点对于向量本身来说是没有意义的）

列优先(一个点是一个列向量，而非行向量)，变换矩阵在乘号左边.
====================================================================================================================================================
Tutorial 09:
左下角: (-1.0f, -1.0f, 0.0f)  --clamp--> (0.0f, 0.0f, 0.0f) 黑色
右下角: (1.0f, -1.0f, 0.0f)   --clamp--> (1.0f, 0.0f, 0.0f) 红色
上角:   (0.0f, 1.0f, 0.0f)    --clamp--> (0.0f, 1.0f, 0.0f) 绿色

插值(Interpolation)经常作用的对象是: normal, texture.
作为数学常识，一个顶点肯定确定不了一个法线，至少3个顶点(一个平面)才能唯一确定一条法线，而在OpenGL中每个顶点都对应一条法线，实际上这条法线是 所有包含这个顶点的三角形的法线的平均值。
====================================================================================================================================================
Tutorial 10: Indexed Draw.
这是绘制了一个什么?  绕y轴旋转、底面是三角形的椎体。
问题: 为什么不按逆时针顺序指定顶点? 默认的正反面都绘制?

glDrawElements(GL_TRIANGLES, 12, GL_UNSIGNED_INT, 0);
第三个参数可选值有: GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, GL_UNSIGNED_INT;
最后一个参数: 告诉GPU你要使用的第一个值在缓冲区中的偏移量。The final parameter tells the GPU the offset in bytes from the start of the index buffer to the location of the first index to scan.

